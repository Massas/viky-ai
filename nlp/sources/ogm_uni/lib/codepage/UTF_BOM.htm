<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="VI60_defaultClientScript" content="JavaScript">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="keywords" content="utf, bom">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>FAQ - UTF and BOM</title>
<link rel="stylesheet" type="text/css" 
href="http://www.unicode.org/webscripts/standard_styles.css">
</head>

<body text="#330000">

<form action="http://www.unicode.org/webscripts/POST">
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td colspan="2">
      <table width="100%" border="0" cellpadding="0" cellspacing="0">
        <tr>
          <td class="icon"><a href="http://www.unicode.org/"><img border="0" 
          src="http://www.unicode.org/webscripts/logo60s2.gif" align="middle" 
          alt="[Unicode]" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" 
          href="http://www.unicode.org/unicode/faq/"><font size="3">Frequently    
          Asked Questions</font></a></td>   
          <td class="bar"><a href="http://www.unicode.org" class="bar">Home</a> 
          | <a href="http://www.unicode.org/sitemap/" class="bar">Site Map</a> | 
          <a href="http://www.unicode.org/search/" class="bar">Search </a></td>
        </tr>
      </table>
      </td>
    </tr>
  </table>
  <!-- BEGIN CONTENTS -->
  <table>
    <tr>
      <td class="contents" valign="top">
      <blockquote>
        <h1>UTF &amp; BOM</h1> 
        <h2><a href="#General">General questions, relating to UTF or Encoding Forms:</a></h2>
        <ul>
          <li><a href="#14">Can Unicode text be represented in more than one way?</a></li>
          <li><a href="#1">What is a UTF?</a></li>
          <li><a href="#13">Where can I get more information on encoding forms?</a></li>
			<li><a href="#45">How do I write a UTF converter?</a></li>
          <li><a href="#5">Which of the UTFs do I need to support?</a></li>
	      <li><a href="#37">What are some of the differences between the UTFs?</a></li>
          <li><a href="#36">Why do some UTFs have a BE or LE in their label, as in UTF-16LE?</a></li>
          <li><a href="#15">Are there any byte sequences that are not 
          generated by a UTF? How should I interpret them?</a></li>
          <li><a href="#31">Is there a standard method to package a Unicode character so it fits an 8-Bit ASCII stream?</a></li>
		  <li><a href="#32">Which of these approaches is the best?</a></li>
		  <li><a href="#33">Which of these formats is the most standard?</a></li>
        </ul>
		<h2><a href="#UTF8">UTF-8 FAQ:</a></h2>
		<ul>
          <li><a href="#2">What is the definition of UTF-8?</a></li>
          <li><a href="#3">Is the UTF-8 encoding scheme the same irrespective of 
          whether the underlying processor is little endian or big endian?</a></li>
          <li><a href="#4">Is the UTF-8 encoding scheme the same irrespective of 
          whether the underlying system uses ASCII or EBCDIC encoding?</a></li>
          <li><a href="#30">How do I convert a UTF-16 surrogate pair such as 
			&lt;D800 DC00&gt; to UTF-8? A one four byte sequence or as two separate 
			3-byte sequences?</a></li>
			<li><a href="#39">How do I convert an unpaired UTF-16 surrogate to 
			UTF-8?</a> </li>
        </ul>
		<h2><a href="#UTF16">UTF-16 FAQ:</a></h2>
		<ul>
          <li><a href="#6">What is UTF-16?</a></li>
			<li><a href="#34">What are surrogates?</a></li>
			<li><a href="#35">What is the algorithm for UTF-16?</a></li>
          <li><a href="#8">Why are some people opposed to UTF-16?</a></li>
          <li><a href="#9">Will UTF-16 ever be extended to more than a million 
          characters?</a></li>
          <li><a href="#40">Are there any 16-bit values that are invalid?</a></li>
			<li><a href="#16">Are 
          there any paired surrogates that are invalid?</a></li>
          <li><a href="#17">Since the surrogate pairs will be rare, does that 
          mean I can dispense with them?</a></li>
          <li><a href="#18">When will most implementations of Unicode support 
          surrogates?</a></li>
        </ul>
		<h2><a href="#UTF32">UTF-32 FAQ:</a></h2>
		<ul>
          <li><a href="#36">What is UTF-32?</a></li>
			<li><a href="#10">Should I use UTF-32 (or UCS-4) for storing Unicode 
          strings in memory?</a></li>
          <li><a href="#11">How about using UTF-32 interfaces in my APIs?</a></li>
          <li><a href="#12">Doesn’t it cause a problem to have UTF-16 string APIs, 
          instead of UTF-32 char APIs?</a></li>
			<li><a href="#44">Are there exceptions to the rule of exclusively using string 
			parameters in APIs?</a></li>
			<li><a href="#42">How do I convert a UTF-16 surrogate pair such as 
			&lt;D800 DC00&gt; to UTF-32? As one or as two
			4-byte sequences?</a></li>
			<li><a href="#43">How do I convert an unpaired UTF-16 surrogate to 
			UTF-32?</a> </li>
        </ul>
		<h2><a href="#BOM">Byte Order Mark (BOM) FAQ:</a></h2>
		<ul>
          <li><a href="#22">What is a BOM?</a></li>
          <li><a href="#23">Where is a BOM Useful?</a></li>
			<li> 
        <a href="#38">What should I do with U+FEFF in the 
		middle of a file?</a></li>
          <li><a href="#24">I am using a protocol that has BOM at the start of 
          text. How do I represent an initial ZWNBSP?</a></li>
			<li><a href="#25">When a BOM is used, is it only in 16-bit Unicode 
          text?</a></li>
			<li><a href="#29">Can a UTF-8 data stream contain the BOM character 
          (in UTF-8 form)? If yes, does it affect the byte order?</a></li>
			<li><a href="#26">How do I tag data that does not interpret FEFF as a 
          BOM?</a></li>
			<li><a href="#27">Why wouldn&#x2019;t I always use a protocol that requires a 
          BOM?</a></li>
			<li><a href="#28">How I should deal with BOMs?</a></li>
        </ul>
        <h2><a name="General">General questions, relating to UTF or Encoding Form</a></h2>
		<p class="q"><a name="14"></a>Q: Can Unicode text be represented in more    
        than one way?</p>   
        <p class="a">A: Yes, there are several possible representations of    
        Unicode data, including UTF-8,&nbsp; UTF-16 and UTF-32. In addition,    
        there are compression transformations such as the one described in the   
        <i><a href="http://www.unicode.org/reports/tr6/">Unicode Technical 
        Report #6: A Standard Compression Scheme for Unicode</a></i>.   
        <a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="1"></a>Q: What is a UTF?</p>   
        <p class="a">A: A <i>Unicode transformation format</i> (UTF) is an   
        algorithmic mapping from every Unicode code point (except <a href="#surrogates">surrogate code 
		points</a>) to a unique byte   
        sequence. The ISO/IEC 10646 standard uses the term  &#x201C;UCS transformation   
        format&#x201D; for UTF; the two terms are merely synonyms for the same concept. </p>  
        <p class="a">Each UTF is reversible, thus every UTF supports <i>lossless round tripping</i>: mapping    
        from any Unicode coded character sequence S to a sequence of bytes and    
        back will produce S again. To ensure round tripping, a UTF mapping <i>   
        must also</i> map all code points that are not valid Unicode characters to    
        unique byte sequences. These invalid code points are the 66 <i>noncharacters</i>  
        (including FFFE and FFFF), as well as    
        unpaired surrogates.&nbsp;</p>  
        <p class="a">The <a href="http://www.unicode.org/reports/tr6/">SCSU</a>    
        compression method, even though it is reversible, is not a UTF because the same string can map to very    
        many different byte sequences, depending on the particular SCSU  
        compressor. <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#MD">MD]</a></p>
        
        <p class="q"><a name="13"></a>Q. Where can I get more information on    
        encoding forms?</p>   
        <p class="a">A: For the formal definition of UTFs see Section 3.9 
		&quot;Unicode Encoding Forms&quot; in the 
		<a href="http://www.unicode.org/versions/Unicode4.0.0/">Unicode Standard</a>. For more information on encoding 
		forms see <a href="http://www.unicode.org/reports/tr17/">Uniocode 
		Technical Report UTR #17:<i> Character Encoding Model</i></a><i> </i>
		<a href="attribution.html#AF">[AF]</a></p>
        
        <p class="q"><a name="45"></a>Q. How do I write a UTF converter?</p>   
        <p class="a">A: For sample code for UTF converters see
		<a href="http://www.unicode.org/Public/PROGRAMS/CVTUTF/">
		http://www.unicode.org/Public/PROGRAMS/CVTUTF/</a>. <i> &nbsp;</i><a href="attribution.html#AF">[AF]</a></p>
        
        <p class="q"><a name="5"></a>Q. Which of the UTFs do I need to support?</p>   
        <p class="a">A: UTF-8 is most common on the web. UTF-16 is used by Java and Windows. UTF-32 
		is 
		used by various Unix systems. The conversions between all of them are 
		algorithmically based, fast and lossless. This makes it easy to support 
		data input or output in multiple formats, while using a particular UTF 
		for internal storage or processing.&nbsp; <a href="attribution.html#AF">
		[AF]</a> &amp; [<a href="attribution.html#MD">MD]</a></p>   
        
        <p class="q"><a name="37"></a>Q. What are some of the differences 
		between the UTFs?</p>   
        <p class="a">A: The following table summarizes some of the properties of 
		each of the UTFs.&nbsp;</p>
		<blockquote>
		<table border="1" cellspacing="0" cellpadding="2">
			<tr>
				<th style="text-align:left">
				Name</th>
				<th>
				UTF-8</th>
				<th>
				UTF-16</th>
				<th>
				UTF-16BE</th>
				<th>
				UTF-16LE</th>
				<th>
				UTF-32</th>
				<th>
				UTF-32BE</th>
				<th>
				UTF-32LE</th>
			</tr>
			<tr>
				<td>
				Smallest code point</td>
				<td align="right">
				0000</td>
				<td align="right">
				0000</td>
				<td align="right">
				0000</td>
				<td align="right">
				0000</td>
				<td align="right">
				0000</td>
				<td align="right">
				0000</td>
				<td align="right">
				0000</td>
			</tr>
			<tr>
				<td>
				Largest code point</td>
				<td align="right">
				10FFFF</td>
				<td align="right">
				10FFFF</td>
				<td align="right">
				10FFFF</td>
				<td align="right">
				10FFFF</td>
				<td align="right">
				10FFFF</td>
				<td align="right">
				10FFFF</td>
				<td align="right">
				10FFFF</td>
			</tr>
			<tr>
				<td>
				Code unit size</td>
				<td align="center">
				8 bits</td>
				<td align="center">
				16 bits</td>
				<td align="center">
				16 bits</td>
				<td align="center">
				16 bits</td>
				<td align="center">
				32 bits</td>
				<td align="center">
				32 bits</td>
				<td align="center">
				32 bits</td>
			</tr>
			<tr>
				<td>
				Byte order</td>
				<td align="center">
				N/A</td>
				<td align="center">
				&lt;BOM&gt;</td>
				<td align="center">
				big-endian</td>
				<td align="center">
				little-endian</td>
				<td align="center">
				&lt;BOM&gt;</td>
				<td align="center">
				big-endian</td>
				<td align="center">
				little-endian</td>
			</tr>
			<tr>
				<td>
				Minimal bytes/character</td>
				<td align="center">
				1</td>
				<td align="center">
				2</td>
				<td align="center">
				2</td>
				<td align="center">
				2</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
			</tr>
			<tr>
				<td>
				Maximal bytes/character</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
				<td align="center">
				4</td>
			</tr>
		</table>
		</blockquote>
		<p class="a">In the table &lt;BOM&gt; indicates that the byte order is 
		determined by a byte order mark, if present at the beginning of the data 
		stream, otherwise it is big-endian.&nbsp;<a href="attribution.html#AF">[AF]</a></p>   
        
        <p class="q"><a name="36"></a>Q. Why do some of the UTFs have a BE or LE 
		in their label, such as UTF-16LE?</p>
		<p class="a">A. UTF-16 and UTF-32 use code units that are two and four 
		bytes long respectively. For these UTFs, there are three sub-flavors: 
		BE, LE and unmarked. The BE form uses big-endian byte serialization 
		(most significant byte first), the LE form uses little-endian byte 
		serialization (least significant byte first) and the unmarked form uses 
		big-endian byte serialization by default, but may include a byte order 
		mark at the beginning to indicate the actual byte serialization used. <a href="attribution.html#AF">[AF]</a> </p>
		
        <p class="q"><a name="15"></a>Q: Are there any byte sequences that    
        are not generated by a UTF? How should I interpret them?</p>   
        <p class="a">A: None of the UTFs can generate <i>every</i> arbitrary byte 
		sequence. For example, in UTF-8 every byte of the form 110xxxxx<i><sub>2</sub></i>
        <i>must</i> be followed with a byte of the form 10xxxxxx<i><sub>2</sub></i>. 
        A sequence such as &lt;110xxxxx<i><sub>2</sub></i> 0xxxxxxx<i><sub>2</sub></i>&gt; 
        is illegal, and must never be generated. When faced with this illegal 
        byte sequence while transforming or interpreting, a UTF-8 conformant 
        process must treat the first byte 110xxxxx<i><sub>2</sub></i> as an 
        illegal termination error: for example, either signaling an error, 
        filtering the byte out, or representing the byte with a marker such as 
        FFFD (REPLACEMENT CHARACTER). In the latter two cases, it will continue 
        processing at the second byte 0xxxxxxx<i><sub>2</sub></i>.</p>
        <p class="a">A conformant process <i>must not</i> interpret illegal or  
        ill-formed byte sequences as characters, however, it may take error 
		recovery actions. No conformant process&nbsp; may use irregular byte  
        sequences to encode out-of-band information. 
        <a href="attribution.html#MD">[MD]</a></p>
        
        <p class="q"><a name="31"></a>Q: Is there a standard method to package a 
		Unicode character so it fits an 8-Bit ASCII stream?</p>
		<p class="a">A: There are three or four options for making Unicode fit into 
		an 8-bit format.</p>
		<p class="a">a) Use UTF-8. This preserves ASCII, but not Latin-1, 
		because the characters &gt;127 are different from Latin-1. UTF-8 uses 
		the bytes in the ASCII only for ASCII characters. Therefore, it works 
		well in any environment where ASCII characters have a significance as 
		syntax characters, e.g. file name syntaxes, markup languages, etc., but 
		where the all other characters may use arbitrary bytes. <br>
		<u>Example</u>: “Latin Small Letter s with Acute” (015B) would be 
		encoded as two bytes: C5 9B.</p>
		<p class="a">b) Use Java or C style escapes, of the form \uXXXXX or \xXXXXX. 
		This format is not standard for text files, but well defined in the 
		framework of the languages in question, primarily for source files.<br>
		<u>Example</u>: The Polish word “wyjście” with character “Latin Small 
		Letter s with Acute” (015B) in the middle (ś is one character) would 
		look like: “wyj\u015Bcie&quot;.</p>
		<p class="a">c) Use the &amp;#xXXXX; or &amp;#DDDDD; numeric character escapes 
		as in HTML or XML. Again, these are not standard for plain text files, 
		but well defined within the framework of these markup languages.<br>
		<u>Example</u>: “wyjście” would look like “wyj&amp;#x015B;cie&quot;</p>
		<p class="a">d) Use <a href="http://www.unicode.org/reports/tr6/">SCSU</a>. 
		This format compresses Unicode into 8-bit format, preserving most of 
		ASCII, but using some of the control codes as commands for the decoder. 
		However, while ASCII text will look like ASCII text after being encoded 
		in SCSU, other characters may occasionally be encoded with the same byte 
		values, making SCSU unsuitable for 8-bit channels that blindly interpret 
		any of the bytes as ASCII characters.<br>
		<u>Example</u>: “&lt;SC2&gt; wyjÛcie” where &lt;SC2&gt; indicates the byte 0x12 and 
		“Û” corresponds to byte 0xDB. <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#KW">KW]</a></p>
		        <p class="q"><a name="32"></a>Q: Which of these approaches is the best?</p>   
        <p class="a">A: That depends on the circumstances: Of these four  
        approaches, d) uses the least space, but cannot be used <i>transparently</i> in most 8-bit environments. a) is the most widely supported in  
        plain text files and b) and c) use the most space, but are widely  
        supported for program source files in Java and C, or <i>within</i> HTML and XML files respectively.&nbsp; 
        <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#KW">KW]</a></p>
        <p class="q"><a name="33"></a>Q: Which of these formats is the most    
        standard? </p>
        <p class="a">A: All four require that the receiver can understand that  
        format, but a) is considered one of the three equivalent Unicode  
        Encoding Forms and therefore standard. The use of b), or c) out of their  
        given context would definitely be considered non-standard, but could be  
        a good solution for internal data transmission. The use of SCSU is  
        itself a standard (for compressed data streams) but few general purpose  
        receivers support SCSU, so it is again most useful in internal data  
        transmission. <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#KW">KW]</a></p>
		<h2><a name="UTF8">UTF-8</a> FAQ</h2>
        
		<p class="q"><a name="2"></a>Q: What is the definition of UTF-8?</p>   
        <p class="a">A. UTF-8 is the byte-oriented encoding form of Unicode. For 
        details of its definition, see Section 2.5 &#x201C;Encoding Forms&#x201D; and Section 
        3.9  &#x201C;<a href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G7404"> 
		Unicode Encoding Forms</a> &#x201D; in the <a href="http://www.unicode.org/versions/Unicode4.0.0/">Unicode 
        Standard</a>. See, in particular, Table 3-5 <i>UTF-8 Bit Distribution</i> 
        and Table 3-6 <i>Well-formed UTF-8 Byte Sequences</i>, which give 
        succinct summaries of the encoding form. Also    
        see&nbsp; <a href="ftp://www.unicode.org/Public/PROGRAMS/CVTUTF/">sample  
        code</a> which implements conversions between UTF-8 and other    
        encoding forms. &nbsp;Make sure you refer to the latest version of the 
		Unicode Standard, as the <a href="http://www.unicode.org/consortium/utc.html">   
        Unicode Technical Committee</a> has tightened the definition of UTF-8  
        over time to more strictly enforce unique sequences and to prohibit  
        encoding of certain invalid characters. There is an Internet <a href="http://www.ietf.org/rfc/rfc2279.txt">RFC 2279</a>  
        about UTF-8. UTF-8 is also defined in    
        Annex D of ISO/IEC 10646. <a href="attribution.html#MD">[MD]</a></p>   
        <p class="q"><a name="3"></a>Q: Is the UTF-8 encoding scheme the same    
        irrespective of whether the underlying processor is little endian or big    
        endian?</p>
        <p class="a">A: Yes. Since UTF-8 is interpreted as a sequence of bytes,  
        there is no endian problem as there is for encoding forms that use  
        16-bit or 32-bit code units. Where a BOM is used with UTF-8, it is <i> 
        only</i> used as an ecoding signature to distinguish UTF-8 from other encodings — it has nothing  
        to do with byte order.&nbsp; 
        <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#KW">KW]</a></p> 
        <p class="q"><a name="4"></a>Q: Is the UTF-8 encoding scheme the same    
        irrespective of whether the underlying system uses ASCII or EBCDIC    
        encoding?</p>
        <p class="a">A: There is only one definition of UTF-8. It is the precisely the same, 
		whether the data were converted from ASCII or EBCDIC based character 
		sets. However, byte sequences from standard UTF-8 won&#x2019;t interoperate 
		well in an EBCDIC system, because of the different arrangements of 
		control codes between ASCII and EBCDIC.
		<a href="http://www.unicode.org/reports/tr16/">Unicode Technical Report #16:
		<i>UTF-EBCDIC</i></a> defines is a specialized UTF&nbsp; that will 
		interoperate in EBCDIC systems. 
        <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#KW">KW]</a></p>
        
        <p class="q"><a name="30"></a>Q: How do I convert a UTF-16 surrogate 
		pair such as &lt;D800 DC00&gt; to UTF-8? A one four byte sequence or as two 
		separate 3-byte sequences?</p>   
        <p class="a">A: The definition of UTF-8 requires that supplementary 
		characters (those using surrogate pairs in UTF-16) be encoded with a 
		single four byte sequence. However, there is a widespread practice of generating 
		pairs of three byte sequences in older software, especially software which pre-dates the    
        introduction of UTF-16 or that is interoperating with UTF-16 
		environments under particular constraints. Such an encoding is <i>not conformant</i>    
        to UTF-8 as defined. See <a href="http://www.unicode.org/reports/tr26/">UTR    
        #26: Compatability Encoding Scheme for UTF-16: 8-bit (CESU)</a> for a 
		formal description of such a non-UTF-8 data format. When using CESU-8, 
		great care must be taken that data is not accidentally treated as if it 
		was UTF-8, due to the similarity of the formats.   
        <a href="attribution.html#AF">[AF]</a> &amp; [<a href="attribution.html#MD">MD]</a></p>
        
        <p class="q"><a name="39"></a>Q: How do I convert an unpaired UTF-16 surrogate 
		to UTF-8? </p>   
		<p class="a">A different issue arises if an <i>unpaired</i> surrogate is 
		encountered when converting ill-formed UTF-16 data. By represented such 
		an unpaired surrogate on its own as 
		a 3-byte sequence, the resulting UTF-8 data stream would become 
		ill-formed. While it faithfully reflects the nature of the input, 
		Unicode conformance requires that encoding form conversion always 
		results in valid data stream. Therefore a converter<i> must</i> treat 
		this as an error. <a href="attribution.html#AF">[AF]</a></p>
        
		<h2><a name="UTF16">UTF-16</a> FAQ</h2>
		<p class="q"><a name="6"></a>Q: What is UTF-16?</p>   
        <p class="a">A: UTF-16 uses a single 16-bitcode unit to encode the most 
		common 63K characters, and a pair of 16-bit code unites, called 
		surrogates, to encode the 1M less commonly used characters in Unicode.</p>
		<p class="a">Originally, Unicode was designed as a pure 16-bit 
        encoding, aimed at representing all modern scripts. (Ancient scripts 
        were to be represented with private-use characters.) Over time, and 
        especially after the addition of over 14,500 composite characters for 
        compatibility with legacy sets, it became clear that 16-bits were not 
        sufficient for the user community. Out of this arose UTF-16. 
        <a href="attribution.html#AF">[AF]</a></p>
		<p class="q">Q: What are <a name="34">surrogates</a>?</p>
		<p class="a">A: Surrogates are code points from two special ranges of Unicode 
		values, reserved  
        for use as the leading, and trailing values of paired code units 
		in UTF-16. Leading, also called high, surrogates are  
        from D800<sub>16</sub> to DBFF<sub>16</sub>, and trailing, or low, 
		surrogates are from DC00<sub>16</sub> to DFFF<sub>16</sub>. They are called 
		surrogates, since they do not represent characters directly, but only as a 
		pair. 
        <a href="attribution.html#MD">[MD]</a></p>
        
<p class="q"><a name="35"></a>Q: What&#x2019;s the algorithm to convert from   
        UTF-16 to character codes?</p>  
        <p class="a">A: The Unicode Standard used to contain a short algorithm,  
        now there is just a bit distribution table. Here are three short code snippets 
        that translate the information from the bit distribution table into C 
        code that will convert to and from UTF-16. </p>
		<p class="a">Using the following type definitions</p>
		<blockquote>
			<pre class="a">typedef int16 UTF16;
typedef int32 UTF32;</pre>
		</blockquote>
		<p class="a">the first snippet calculates 
        the high (or leading) surrogate from a character code C.</p>
        <blockquote>
        <pre class="a">const UTF16 HI_SURROGATE_START = 0xD800</pre>
        <pre class="a">UTF16 X = (UTF16) C;
UTF32 U = (C &gt;&gt; 16) &amp; ((1&lt;&lt;5) - 1);
UTF16 W = (UTF16) U - 1;
UTF16 HiSurrogate = HI_SURROGATE_START | (W &lt;&lt; 6) | X &gt;&gt; 10;
</pre>
        </blockquote>
        <p  class="a">where X, U and W correspond to the labels used in Table 
		3-4 <i>UTF-16 Bit Distribution</i>. The next snippet does the same for the low surrogate.</p>
        <blockquote>
        <pre class="a">const UTF16 LO_SURROGATE_START = 0xDC00</pre>
        <pre class="a">UTF16 X = (UTF16) C;
UTF16 LoSurrogate = (UTF16) (LO_SURROGATE_START | X &amp; ((1&lt;&lt;10) - 1));</pre>
        </blockquote>
<p  class="a">Finally, the reverse, where hi and lo are the high and low 
surrogate, and C the resulting character</p>
        <blockquote>
        <pre class="a">UTF32 X = (hi &amp; ((1&lt;&lt;6) -1)) &lt;&lt; 10 | lo &amp; ((1&lt;&lt;10) -1);
UTF32 W = (hi &gt;&gt; 6) &amp; ((1&lt;&lt;5) - 1);
UTF32 U = W + 1 </pre>
        <pre class="a">UTF32 C = &lt;&lt; 16 | X;</pre>
        </blockquote>
        <p class="a">A caller would need to ensure that C, hi, and lo are in the 
        appropriate ranges. <a href="attribution.html#AF">[AF]</a> </p>
		<p class="q">Q: Isn&#x2019;t there a simpler way to do this?</p>
		<p class="a">A: There is a much simpler computation that does not try to 
		follow the bit distribution table.</p>
		<blockquote>
			<pre class="a">// constants
const UTF32 LEAD_OFFSET = 0xD800 - (0x10000 &gt;&gt; 10);
const UTF32 SURROGATE_OFFSET = 0x10000 - (0xD800 &lt;&lt; 10) - 0xDC00;

// computations
UTF16 lead = LEAD_OFFSET + (codepoint &gt;&gt; 10);
UTF16 trail = 0xDC00 + (codepoint &amp; 0x3FF);

UTF32 codepoint = (lead &lt;&lt; 10) + trail + SURROGATE_OFFSET;</pre>
		</blockquote>
    	<p class="a"><a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="8"></a>Q: Why are some people opposed to UTF-16?</p>   
        <p class="a">A: People familiar with variable width East Asian character 
		sets such as Shift-JIS ( SJIS) are understandably nervous about UTF-16, 
		which sometimes requires two code units to represent a single character. 
		They have are well acquainted with the problems that variable-width 
		codes,&nbsp; have caused.  
        However, there are some important differences between the mechanisms 
		used in SJIS and UTF-16: 
        </p>
        <p class="a">Overlap: </p>
		<ul>
			<li>
			<p class="a">In SJIS, there is overlap between the leading and 
			trailing code unit values, and between the trailing and single code unit values. This causes a number of problems:
			<ul>
				<li>
				<p class="a">It causes false matches. For example, searching for 
              an &#x201C;a&#x201D; may match against the trailing code unit of a Japanese character.
				</li>
				<li>
				<p class="a">It prevents efficient random access. To know whether 
              you are on a character boundary, you have to search backwards to 
              find a known boundary. </li>
				<li>
				<p class="a">It makes the text extremely fragile. If a unit is 
              dropped from a leading-trailing code unit pair, many following characters can be 
              corrupted.</li>
			</ul></li>
			<li>
			<p class="a">In UTF-16, the code point ranges for high and low 
			surrogates, as well as for single units are all completely disjoint.
			None of these problems occur:<ul>
			<li>
			<p class="a">There are no false matches.</p></li>
			<li>
			<p class="a">The location of the character boundary can be directly 
			determined from each code unit value.</p></li>
			<li>
			<p class="a">A dropped surrogate will corrupt only a single 
			character.</p></li>
			</ul>
			</li>
		</ul>
		<p class="a">Frequency: </p>
		<ul>
			<li>
			<p class="a">The vast majority of SJIS characters require 2 units, 
			but characters using single units occur commonly and often have 
			special importance, for example in file names.</li>
			<li>
			<p class="a">With UTF-16, relatively few characters require 2 units.  
            The vast majority of characters in common use are single code units.  
            Even in East Asian text, the incidence of surrogate pairs should be  
            well less than 1% of all text storage on average. (Certain  
            documents, of course, may have a higher incidence of surrogate  
            pairs, just as <i>phthisique</i> is an fairly infrequent word in  
            English, but may occur quite often in a particular scholarly text.) 
            <a href="attribution.html#AF">[AF]</a> &amp;
			<a href="attribution.html#MD">[MD]</a></li>
		</ul>
        <p class="q"><a name="9"></a>Q: Will UTF-16 ever be extended to more    
        than a million characters?</p>   
        <p class="a">A: No. Both Unicode and ISO 10646 have    
        policies in place that formally limit future code assignment to    
        the integer range that can be expressed with current UTF-16 (0 to 
		1,114,111). Even if other encoding forms (i.e. other UTFs) can represent 
		larger intergers, these policies mean that all encoding forms will 
		always represent the same set of characters. Over a million possible codes is far more than enough    
        for the goal of Unicode of encoding characters, not glyphs. Unicode is <i>not</i> designed to encode arbitrary data. If    
        you wanted, for example, to give each  &#x201C;instance of a character on paper    
        throughout history&#x201D; its own code, you might need trillions or    
        quadrillions of such codes; noble as this effort might be, you would not    
        use Unicode for such an encoding.&nbsp;<a href="attribution.html#AF">[AF]</a> 
		&amp; [<a href="attribution.html#MD">MD]</a></p>
        <p class="q"><a name="40"></a>Q: Are there any 16-bit values that are 
		invalid?</p>
		<p class="a">A: The two values FFFE<sub>16</sub> and FFFF<sub>16</sub> as well as the 32 
		values from FDD0<sub>16</sub> to FDEF<sub>16</sub> represent noncharacters. They 
		are invalid in interchange, but may be freely used internal to an 
		implementation. Unpaired surrogates are invalid as well, i.e. any value 
		in the range D800<sub>16</sub> to DBFF<sub>16</sub> not followed by a value in the range DC00<sub>16</sub> 
		to DFFF<sub>16</sub>, or any value in the range DC00<sub>16</sub> to DFFF<sub>16</sub> not preceded by a 
		value in the range D800<sub>16</sub> to DBFF<sub>16</sub>. <a href="attribution.html#AF">[AF]</a></p>
		<p class="q"><a name="16"></a>Q: Are there any paired surrogates that are invalid?</p>   
        <p class="a">A: Some code points are designated as noncharacters. They 
		are invalid in interchange, but may be freely used internal to an 
		implementation. For the 32 noncharacters that are supplementary 
        characters, the corresponding surrogate pairs are listed below.</p>
        <div align="center">
          <center>
          <table border="1" cellpadding="2" cellspacing="0">
            <tr>
              <th>
              UTF-16</th>
              <th>
              UTF-8</th>
              <th>
              UCS-4</th>
            </tr>
            <tr>
              <td>
              D83F DFF*</td>
              <td>
              F0 9F BF B*</td>
              <td>
              0001FFF*</td>
            </tr>
            <tr>
              <td>
              D87F DFF*</td>
              <td>
              F0 AF BF B*</td>
              <td>
              0002FFF*</td>
            </tr>
            <tr>
              <td>
              D8BF DFF*</td>
              <td>
              F0 BF BF B*</td>
              <td>
              0003FFF*</td>
            </tr>
            <tr>
              <td>
              D8FF DFF*</td>
              <td>
              F1 8F BF B*</td>
              <td>
              0004FFF*</td>
            </tr>
            <tr>
              <td>
              D93F DFF*</td>
              <td>
              F1 9F BF B*</td>
              <td>
              0005FFF*</td>
            </tr>
            <tr>
              <td>
              D97F DFF*</td>
              <td>
              F1 AF BF B*</td>
              <td>
              0006FFF*</td>
            </tr>
            <tr>
              <td colspan="3">
              <p align="center" class="a">...</td>
            </tr>
            <tr>
              <td>
              DBBF DFF*</td>
              <td>
              F3 BF BF B*</td>
              <td>
              000FFFF*</td>
            </tr>
            <tr>
              <td>
              DBFF DFF*</td>
              <td>
              F4 8F BF B*</td>
              <td>
              0010FFF*</td>
            </tr>
            <tr>
              <td colspan="3">
              * = E or F</td>
            </tr>
          </table>
          </center>
        </div>
        <p class="a">Surrogate pairs that refer to unassigned characters should 
        not occur in data that you generate, but may legitimately occur in data 
        from a system that&#x2019;s conformant to a later version of the Unicode 
        Standard. <a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="17"></a>Q: Since the surrogate pairs will be rare,    
        does that mean I can dispense with them?</p>   
        <p class="a">A: Just because the characters are rare does <i>not</i>  
        mean that they should be neglected. It will become even more important to support  
        surrogate pairs in the future as they become more widely used for minor  
        scripts, mathematics, and rare Han characters. The fact that the  
        characters are rare <i>can</i> be taken into account when optimizing  
        code and storage, however. <a href="attribution.html#MD">[MD]</a></p> 
        <p class="q"><a name="18"></a>Q: When will most implementations of    
        Unicode support surrogates?</p>   
        <p class="a">A: A growing number of implementations support surrogates,    
        including Windows XP and Microsoft Office. Although Java does not yet    
        support surrogates, there is a set of utilities in   
        <a href="http://oss.software.ibm.com/icu4j/">ICU4J</a> that    
        provides&nbsp;surrogate support at a low level; Java 1.4 will support line    
        layout for surrogates.&nbsp; <a href="attribution.html#MD">[MD]</a></p>   
		<h2><a name="UTF32">UTF-32</a> FAQ</h2>
		<p class="q"><a name="7"></a>Q: What is UTF-32?</p>
        <p class="a">A: Any Unicode character can be  
        represented as a single 32-bit unit in UTF-32. This single 4 code unit  
        corresponds to the Unicode scalar value, which is the abstract number  
        associated with a Unicode character. UTF-32 is a subset of the encoding  
        mechanism called <i>UCS-4</i> in ISO 10646. For more information, see 
        Section 3.9 
		&#x201c;<a href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G7404">Unicode Encoding Forms</a>&#x201d; of <i>
		The Unicode Standard.</i> 
        <a href="attribution.html#AF">[AF]</a></p>
        
		<p class="q"><a name="10"></a>Q: Should I use UTF-32 (or UCS-4) for    
        storing Unicode strings in memory?</p>   
        <p class="a">A: This depends. If you frequently need to access APIs that 
		require string parameters to be in UTF-32, it may be more convenient to 
		work with UTF-32 strings all the time. However, the downside of UTF-32 
		is that it forces you to use 32-bits for each character, when only 21 
		bits are ever needed. The number of significant bits needed for the 
		average character in common texts is much lower, making the ratio 
		effectively that much worse. In many situations that does not matter, 
		and the convenience of having a fixed number of code units per character 
		can be the deciding factor. </p>
		<p class="a">Increasing the storage for the same 
		number of characters does have its cost in applications dealing with 
		large volume of text data: it can mean exhausting cache limits sooner; 
		it can result in noticeably increased read/write times or in reaching 
		bandwidth limits; and it requires more space for storage.What a number of implementations do is to represent strings with 
			UTF-16,	but individual characters values with 
			UTF-32, for and example of the latter see
		<a href="http://www.unicode.org/faq/utf_bom.html#44">below</a>. </p>
		<p class="a">The chief selling point for Unicode is providing a 
        representation for all the world&#x2019;s characters, eliminating the need for 
        juggling multiple character sets and avoiding the associated data corruption 
        problems. These features were enough to swing industry to the side of 
        using Unicode (UTF-16). While a UTF-32 representation does make the 
        programming model somewhat simpler, the increased average storage size 
		has real drawbacks, making a complete transition to UTF-32 less compelling. <a href="attribution.html#AF">
		[AF]</a> &amp; [<a href="attribution.html#MD">MD]</a></p>
		<p class="q"><a name="11"></a>Q: How about using UTF-32 interfaces in my    
        APIs?</p>
        <p class="a">A: Except in some environments that store text as UTF-32 in 
		memory, most Unicode APIs are using UTF-16. With UTF-16 APIs&nbsp; the 
		low level  
        indexing is at the storage or code unit level, with higher-level mechanisms  
        for graphemes or words specifying their boundaries in terms of the  
        code units. This provides efficiency at the low levels, and the  
        required functionality at the high levels.</p>
		<p class="a">If its ever necessary to locate the <i>n</i><sup>th </sup>
		character, indexing by character can be implemented as a high level 
		operation. However, while converting  
        from such a UTF-16 code unit index to a character index or vice versa is fairly  
        straightforward, it does involve a scan through the 16-bit units up to  
        the index point. In a test run, for example, accessing UTF-16 storage as 
        characters, instead of code units resulted in a 10× degradation. While 
		there are some interesting optimizations that can be performed, it will 
		always be slower on average. Therefore locating other boundaries, such 
		as grapheme, word, line or sentence boundaries proceeds directly from 
		the code unit index, not indirectly via an intermediate character code 
		index. 
        <a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="12"></a>Q: Doesn&#x2019;t it cause a problem to have    
        only UTF-16 string APIs, instead of UTF-32 char APIs?</p>   
        <p class="a">A: Almost all international functions (upper-, lower-, 
        titlecasing, case folding, drawing, measuring, collation, 
        transliteration, grapheme-, word-, linebreaks, etc.) should take <i>
        string parameters</i> in the API, <b><i>not</i></b> single code-points 
		(UTF-32). Single code-point APIs almost always produce the wrong results 
		except for very 
        simple languages, either because you need more context to get the right answer, 
        or because you need to generate a sequence of characters to return 
        the right answer, or both. </p>
		<p class="a">For example, any Unicode-compliant 
        collation (See <a href="http://www.unicode..org/reports/tr10/">Unicode 
		Technical Stdandard #10:<i> Unicode Collation Algogrithm (UCA)</i></a>) must be able to handle sequences of more than one 
        code-point, and treat that sequence as a single entity. Trying to collate by handling single code-points  
        at a time, would get the wrong answer. The same will happen for drawing 
		or measuring text a single code-point at a time; because scripts like  
        Arabic are contextual, the width of <i>x</i> plus the width of <i>y</i> is not equal  
        to the width of <i>xy</i>. Once you get beyond basic typography, the same is  
        true for English as well; because of kerning and ligatures the width of  
         &#x201C;fi&#x201D; in the font may be different than the width of  &#x201C;f&#x201D; plus the width  
        of  &#x201C;i&quot;. Casing operations must return strings, not single code-points;  
        see <a href="http://www.unicode.org/charts/case/"> 
        http://www.unicode.org/charts/case/</a> . In particular, the title  
        casing operation requires strings as input, not single code-points at a  
        time.</p>
        <p class="a">Storing a single code point 
        in a struct or class instead of a string, would exclude support for 
        graphemes, such as “ch” for Slovak, where a single code point may not be sufficient, 
		but a character sequence is needed to express what 
        is required. In other words, most API parameters and fields of composite 
		data types should
        <i>not</i> be defined as a character, but as a string. And if they are 
		strings, it does not matter what the internal representation of the 
		string is.</p>
		<p class="a">Given that any industrial-strength text and 
		internationalization support API has to be able to handle sequences of 
		characters, it makes 
		little difference whether the string is internally represented by a 
		sequence of UTF-16 code units, or by a sequence of code-points ( = UTF-32 code units). 
		Both UTF-16 and UTF-8 are designed to make working with substrings easy, 
		by the fact that the sequence of code units for a given code point is 
		unique. <a href="attribution.html#AF">[AF]</a> 
		&amp; [<a href="attribution.html#MD">MD]</a></p>
		<p class="q"><a name="44"></a>Q: Are there exceptions to the rule of exclusively using 
		string parameters in APIs?</p>
        <p class="a">A: The main exception are very low-level    
        operations such as getting character properties (e.g. General Category    
        or Canonical Class in the UCD). For those it is handy to have interfaces 
		that convert quickly to and from UTF-16 and UTF-32, and that allow you 
		to iterate through strings returning UTF-32 values (even though the 
		internal format is UTF-16). <a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="42"></a>Q: How do I convert a UTF-16 surrogate 
		pair such as &lt;D800 DC00&gt; to UTF-32? A one 4-byte sequence or as two 
		4-byte sequences?</p>   
        <p class="a">A: The definition of UTF-32 requires that supplementary 
		characters (those using surrogate pairs in UTF-16) be encoded with a 
		single 4-byte sequence.</p>
        
        <p class="q"><a name="43"></a>Q: How do I convert an unpaired UTF-16 surrogate 
		to UTF-32? </p>   
		<p class="a">A: If an <i>unpaired</i> surrogate is encountered when 
		converting ill-formed UTF-16 data, any conformant converter<i> must</i> 
		treat this as an error. By represented such an unpaired surrogate on its 
		own, the resulting UTF-32 data stream would become ill-formed. While it 
		faithfully reflects the nature of the input, Unicode conformance 
		requires that encoding form conversion always results in valid data 
		stream. <a href="attribution.html#AF">[AF]</a></p>
        
		<h2>Byte Order Mark (<a name="BOM">BOM</a>) FAQ</h2>
        
		<p class="q"><a name="22"></a>Q: What is a BOM?</p>   
        <p class="a">A: A <i>byte order mark </i>(BOM) consists of the character 
        code U+FEFF at the beginning of a data stream, where it can be used  
        as a signature defining the byte order and encoding form, primarily of unmarked plaintext 
        files. Under some higher level protocols, use of a BOM may be mandatory 
		(or prohibited) in the Unicode data stream defined in that 
        protocol. 
        <a href="attribution.html#AF">[AF]</a></p>
        <p class="q"><a name="23"></a>Q: Where is a BOM useful?</p>   
        <p class="a">A: A BOM is useful at the beginning of files that are typed as   
        text, but for which it is not known whether they are in big or little endian format—it 
		can also serve as a hint indicating that the file is in Unicode, as 
		opposed to in a legacy encoding and furthermore, it act as a signature 
		for the specific encoding form used . <a href="attribution.html#MD">[MD]</a> 
        &amp; [<a href="attribution.html#AF">AF]</a> 
        </p>  
        <p class="q"><a name="34"></a>Q: What does &#x2018;endian&#x2019; mean?</p>  
        <p class="a">A: Data types longer than a byte can be stored in computer 
        memory with the most significant byte (MSB) first or last. The former is 
        called big-endian, the latter little-endian. When data are exchange in 
        the same byte order as they were in the memory of the originating 
        system, they may appear to be in the wrong byte order on the receiving 
        system. In that situation, a BOM would look like 0xFFFE which is a 
        noncharacter, allowing the receiving system to apply byte reversal 
        before processing the data. UTF-8 is byte oriented and therefore does 
        not have that issue. Nevertheless, an initial BOM might be useful to 
        identify the datastream as UTF-8. <a href="attribution.html#AF">[AF]</a> 
        </p> 
        <p class="q"><a name="25"></a>Q: When a BOM is used, is it only in    
        16-bit Unicode text?</p>   
        <p class="a">A: No, a BOM can be used as a signature no matter how the 
        Unicode text is transformed: UTF-16, UTF-8, UTF-7, etc. The exact bytes 
        comprising the BOM will be whatever the Unicode character FEFF is 
        converted into by that transformation format. In that form, the BOM 
        serves to indicate both that it is a Unicode file, and which of the 
        formats it is in. Examples:</p>
        <div align="center">
          <center>
          <table border="1" cellpadding="2" cellspacing="0">
            <tr>
              <th width="50%">Bytes</th>
              <th width="50%">Encoding Form</th>
            </tr>
            <tr>
              <td width="50%">00 00 FE FF</td>
              <td width="50%">UTF-32, big-endian</td>
            </tr>
            <tr>
              <td width="50%">FF FE 00 00</td>
              <td width="50%">UTF-32, little-endian</td>
            </tr>
            <tr>
              <td width="50%">FE FF</td>
              <td width="50%">UTF-16, big-endian</td>
            </tr>
            <tr>
              <td width="50%">FF FE</td>
              <td width="50%">UTF-16, little-endian</td>
            </tr>
            <tr>
              <td width="50%">EF BB BF</td>
              <td width="50%">UTF-8</td>
            </tr>
          </table>
          </center>
        </div>
        <p><a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="29"></a>Q: Can a UTF-8 data stream contain the BOM    
        character (in UTF-8 form)? If yes, then can I still assume the remaining    
        UTF-8 bytes are in big-endian order?</p>   
        <p class="a">A: Yes, UTF-8 can contain a BOM. However, it makes <i>no</i>  
        difference as to the endianness of the byte stream. UTF-8 always has the  
        same byte order. An initial BOM is <i>only</i> used as a signature &#x2014; an  
        indication that an otherwise unmarked text file is in UTF-8. Note that 
		some recipients of UTF-8 encoded data do not expect a BOM. Where UTF-8 
		is used<i> transparently</i> in 8-bit environments, the use of a BOM 
		will interfere with any protocol or file format that expects specific 
		ASCII characters at the beginning, such as the use of &quot;#!&quot; of at the 
		beginning of Unix shell scripts.<i> </i><a href="attribution.html#AF">
		[AF]</a> &amp; [<a  
        href="attribution.html#MD">MD]</a></p>
        <p class="q"><a name="38"></a>Q: What should I do with U+FEFF in the 
		middle of a file?</p>   
        <p class="a">A: In the absence of a protocol supporting its use as a BOM and when not at the   
        beginning of a text stream, U+FEFF should normally not occur. For 
		backwards compatibility it should be treated as ZERO WIDTH  
        NON-BREAKING SPACE (ZWNBSP),   
        and is then part of the content of the file or string. The use of  
        U+2060 WORD JOINER is strongly preferred over ZWNBSP for expressing word joining 
		semantics since it cannot be confused with a BOM. When designing a markup 
		language or data protocol, the use of U+FEFF can be restricted to that 
		of Byte Order Mark. In that case, any U+FEFF occurring in the middle of 
		the file can be ignored, or treated as an error.&nbsp;<a href="attribution.html#AF">[AF]</a> 
        </p>
        <p class="q"><a name="24"></a>Q: I am using a protocol that has BOM at    
        the start of text. How do I represent an initial ZWNBSP?</p>   
        <p class="a">A: Use U+2060 WORD JOINER instead.&nbsp;<a href="attribution.html#MD">[MD]</a></p>  
        <p class="q"><a name="26"></a>Q: How do I tag data that does not    
        interpret FEFF as a BOM?</p>   
        <p class="a">A: Use the tag <tt>UTF-16BE</tt> to indicate big-endian  
        UTF-16 text, and <tt>UTF-16LE</tt> to indicate little-endian UTF-16  
        text. If you do use a BOM, tag the text as simply <tt>UTF-16</tt>. 
        <a href="attribution.html#MD">[MD]</a></p>
        <p class="q"><a name="27"></a>Q: Why wouldn&#x2019;t I always use a protocol    
        that requires a BOM?</p>   
        <p class="a">A: Where the data is typed, such as a field in a database,  
        a BOM is unnecessary. In particular, if a text data stream is marked as  
        UTF-16BE, UTF-16LE, UTF-32BE or UTF-32LE, a BOM is neither necessary nor <i>permitted</i>. 
		Any FEFF would be interpreted as a ZWNBSP.</p>
		<p class="a">Do not tag every string in a database or set of fields with a BOM, 
		since it wastes space and complicates string concatenation. Moreover, it also means two data fields may have  
        precisely the same content, but not be binary-equal (where one is  
        prefaced by a BOM). <a href="attribution.html#MD">[MD]</a></p> 
        <p class="q"><a name="28"></a>Q: How I should deal    
        with BOMs?</p>   
        <p class="a">A: Here are some guidelines to follow: </p>
        <ol>
          <li>
          <p class="a">A particular protocol (e.g. Microsoft conventions for 
          .txt files) may require use of the BOM on certain Unicode data 
          streams, such as files. When you need to conform to such a protocol, 
          use a BOM. </li>
          <li>
          <p class="a">Some protocols allow optional BOMs in the case of 
          untagged text. In those cases,
          <ul>
            <li>
            <p class="a">Where a text data stream is known to be plain text, but 
            of unknown encoding, BOM can be used as a signature. If there is no 
            BOM, the encoding could be anything.</li>
            <li>
            <p class="a">Where a text data stream is known to be plain Unicode 
            text (but not which endian), then BOM can be used as a signature. If 
            there is no BOM, the text should be interpreted as big-endian.</li>
          </ul>
          </li>
          <li>
			<p class="a">Some byte oriented protocols expect ASCII characters at 
			the beginning of a file. If UTF-8 is used with these protocols, use 
			of the BOM as encoding form signature should be avoided.</li>
          <li>
          <p class="a">Where the precise type of the data stream is known (e.g.  
          Unicode big-endian or Unicode little-endian), the BOM should not be  
          used. In particular, whenever a data stream is declared to be 
			UTF-16BE, UTF-16LE, UTF-32BE or UTF-32LE a BOM <i>must</i> not be 
			used. <a href="attribution.html#AF">[AF]</a>   
        &amp; <a href="attribution.html#MD">[MD]</a></li> 
        </ol>
        
        <p class="a">&nbsp;</p>
        <hr width="50%">
        <div align="center">
          <center>
          <table cellspacing="0" cellpadding="0" border="0">
            <tr>
              <td><a href="http://www.unicode.org/copyright.html">
              <img src="http://www.unicode.org/img/hb_notice.gif" border="0" 
              alt="Access to Copyright and terms of use" width="216" 
              height="50"></a></td>
            </tr>
          </table>
          <script language="Javascript" type="text/javascript" 
          src="http://www.unicode.org/webscripts/lastModified.js"></script>
          </center>
        </div>
      </blockquote>
      </td>
    </tr>
  </table>
</form>

</body>

</html>